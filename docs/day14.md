# 열넷째 날

슬슬 "쉽게" 푸니까 느립니다.

그래도 Advent of Code의 장점은, 답을 구할 수만 있으면 대회급 최적화는 하지 않아도 된다는 점인 것 같습니다.

## 입력 파싱

[13일차](https://adventofcode.com/2022/day/13)에 비하면 쉽습니다.

9일차와 비슷하게 `(i32, i32)`이면 되고, `Vec2D`, `Point` 등의 tuple structure로 쉽게 처리했습니다.

점 하나하나야 쉼표로 나뉘어져 있는 정수지만, 직선도 파싱해야 합니다.

다행히 그냥 화살표로 나뉘어져 있어서 `line.split("->").map(|w| w.trim()).foobar()`로 처리하면 됩니다.

## 구조 짜기

종종 나오는 2차원 그래프에서 '벽'이 존재하는 문제입니다.

문제는 그래프 공간이 한정되어 있지 않고 입력에 따라 무한히 클 수 있다는 점입니다.

게다가 모래가 흘러내리다 보면 x축으로는 확장될 수도 있습니다.

그래서 그냥 '벽'이 존재하는 좌표를 HashSet으로 관리했습니다.

Part2가 이례적으로 2400ms가 넘게 걸린 것은 HashSet이 너무 커져서일지도 모르겠습니다.

## 시간 측정!

간만에 오래 걸리는 문제가 나와서, `main.rs`에 시간을 측정하는 기능을 추가했습니다.

## Part 1

모래가 처음에느 쌓이다가, 어느 순간에 삼각뿔 모양으로 다 쌓이고 나면 심연으로 무한히 떨어지기 시작합니다.

기본적으로 모래는 '벽 위'에 쌓여야 하므로, 주어진 벽 중에서 가장 '낮은' (문제 상으로는 `y`값 중 최대) 곳을 저장해놓았다가,

모래의 `y` 좌표가 해당 좌표를 넘어서는 순간을 무한히 떨어지는 시작으로 판단했습니다.

모래가 쌓일 때마다 새로운 모래가 해당 공간을 occupy하는 것이므로 `cave.walls.insert(sand)`를 해주어야 합니다.

## Part 2

보통 문서를 여기까지 쓰다 보면 좀더 효율적인 해결 방안이 생각나고 그러는데 아직도 모르겠습니다.

파트 1은 '가장 낮은 벽'의 `y` 좌표를 돌파하는 순간을 답으로 셌다면,  
파트 2에서는 모래가 `(500, 0)`에서 한 칸도 움직이지 못하는 경우를 답으로 세면 됩니다.

혹시나 해서 검사해보니 파트 2에선 `cave.walls.len()`이 `28672`까지 가네요...

그래도 일단 60초가 걸린것도 아니고 2.4초 정도 걸린 거니까 넘어가려고 합니다!
