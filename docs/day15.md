# 열다섯째 날

뭔가 세그먼트 트리나 Disjoint Set 같은 걸로 멋들어지게 풀 수도 있었을 것 같지만 하다보니 그냥 전용 자료구조 하나를 새로 정의해서 풀었습니다.

## 입력 파싱

입력에서는 "센서의 위치"와 "센서가 감지한 가장 가까운 비컨" 두 개만 뽑아내면 됩니다.

따라서 처음엔 이런 구조 두 개로 시작합니다:

```Rust
struct Point(i32, i32);
struct Beacon(Point, Point);
```

처음에는 `i32`로 처리했는데, 파트 2에서 `4_000_000 ^ 2`가 필요해서 `i64`로 바꿨습니다.

## Part 1: Naïve implementation

입력에서 주어진 "가장 가까운 비컨"은 Manhattan distance (택시 거리라고도 할겁니다.)로 주어집니다.

해당 비컨이 "가장 가까워야 한다"는 정보를 이용해서, 센서 하나당 다이아몬드 꼴로 비컨이 존재할 수 없는 영역을 지워낼 수 있습니다.

그리고, 파트 1에서는 특정 `y`에서, 지워진 영역의 칸 수를 세라고 합니다.

그래서 처음에는 각 센서에 대해서, 해당 y에서 지워낸 x의 좌표를 그냥 HashSet에 떄려 넣었습니다.

이렇게 되면 Part 1의 복잡도는 센서의 수를 S, Manhattan Distance의 magnitude (10, 100, 1000, ...)을 M이라 했을 때, `O(S * M)`이 됩니다.

## Part 2: Naïve로는 풀 수 없음

여기서는 이제 "특정 Boundary"가 주어졌을 때,

주어진 센서들 제공하는 다이아몬드를 다 지워내고 나면 '단 한 칸'만이 남게 된다는 정보를 추가 제공합니다.

문제는 센서의 수 S는 10개 정도로 적은데, 애초에 Distance Magnitude M이 약 `~1_000_000`이었다는 겁니다.

그래서 파트 1에서는 약 10_000_000회 연산으로 5초가 걸렸습니다.

그런데 파트 2에서는 특정 Boundary에 있는 `y`값을 다 검사해야 돼서, Boundary의 크기를 `L`이라 했을 때 연산 복잡도가 `O(S * L * M)`이 됩니다.

대충 10^12라서 시간이 너무 오래 걸립니다.

새로운 풀이가 필요했습니다.

## Part 2: Advanced Implementation

그래서 distance magnitude `M`을 지워낼 수 있는 방식을 고민했습니다:

"Range" 개념을 도입하면 가능할 것 같았습니다.

예를 들어 Naïve 구현에서 `(Sensor, Beacon): (0,0), (1000,1000)`으로 주어졌을 떄,

`y=500`에서 지워내는 칸의 개수를 기존에는 `x=-500 ~ x=500`까지 HashSet에 하나하나 넣었다면,

이제는 `y=500`은 `Range(-500, 500)`이 불가능하다! 라고 표현하려 한 것입니다.

그래서, 관련해서 여러 가지를 구현했습니다.

1. 두 개의 Range가 아예 겹치지 않는 경우

첫 센서에 의해서 (-500, 500)이 지워졌는데, 두 번째 센서에서 (600,1000)을 지워낼 수 있습니다.

이 경우 두 Segment를 지웠다는 것을 들고 있어야 해서 여러 개의 `Range`를 래핑하는 상위 구조 `MultiRange`를 짰습니다.

2. 잡다한 사칙연산

첫 센서에 의해 (-500, 500)이 지워졌는데, 두 번째 센서가 (300, 1000)을 지워낼 경우, (-500, 1000)을 지워냈다고 합칠 수 있으면 편할 것입니다.

마찬가지로 (-500, 1000)에서 (200, 300) 부분을 지워달라고 했을 때, (-500, 200), (300, 1000)으로 갈라질 수 있어도 편할 것입니다.

하나하나 구현해 주었고, 관련해서 디버그가 귀찮을 것 같아 덧셈뺄셈 하나 구현할 때마다 테스트도 짰습니다.

3. Test

이번 문제 풀이에서 가장 맘에 드는 부분입니다.

정말 많은 테스트를 짰고, 덕분에 문제 예시 및 본 문제는 한 번에 통과했습니다.

이진 탐색도 기본기가 부족해서 확신이 없었던 관계로 테스트를 좀 짰습니다.
