# 여덟째 날

엄청 어렵진 않은데 귀찮고, 실수할 여지가 많은 문제였습니다.  
고생한 케이스들 위주로 기술합니다.

## 공통

`main.rs`에서 `Day##::solve_part_1()` 해주는 게 뭔가 거슬렸습니다.  
그래서 `type Today = Day##;` 줄을 추가해서 해결했습니다.

## Part 1

나무의 높이가 `0`일 수 있다는 것을 놓쳤습니다.  
"Edgecase"를 따로 처리해주기 귀찮아서, "지금까지 본 나무 중 제일 큰 높이"의 초기값을 `0`으로 두고 시작했는데, 이렇게 하니까 "Edge"에 있는 높이가 `0`인 나무가 보이지 않는다는 문제가 생겼습니다.  
이걸 처리하느라 너무 귀찮았네요.

그렇다고 초기값을 `-1`로 두자니, `i8`보다는 `u8`을 쓰고 싶어서 고민하다가,  
이후의 문제에서 계속 높이의 "상대값"만 사용한다는 것을 이용해 그냥 파싱할 때 전체적으로 높이를 +1 해주는 것으로 해결했습니다.

그 세팅만 하고 나면 네 방향으로 높이 최대값 저장해가며 "내가 지금까지의 최대값인지" 여부만 검사해주면 됩니다.

## Part 2

전체를 다 스캔해야 하는데요, 그냥 `O(N^3)`로 돌렸습니다.  
각 나무에 대해서 `scenic_score`를 구할 때, 열 방향 스캔 한 번, 행 방향 스캔 한 번이 필요하니까 `2N`, 모든 나무에 대해 이터레이션 돌려야 하니까 `N^2`.
아마 stack 이용해서 N^2 + N^2로 줄일 수 있을 것 같기도 한데, 테스트 인풋이 그렇게까진 크지 않아서 그 알고리즘을 구상 및 구현하는 코스트가 더 컸을 것 같아요.

Scenic score를 구할 때, 시야가 가리는 순간이 오면 `ans` 값에 곱을 반영하고 `break`을 해주었어야 하는데 이걸 까먹어서 전체적으로 점수가 뻥튀기 되는 버그가 있었습니다. 이것도 잡는데 시간 좀 걸렸습니다.

특이사항으로 "Cartesian Product"를 쓰고 싶었습니다.  
즉 `(0, 0), (0, 1), ..., (0,width - 1), (1, 0), ..., (1, width - 1), ... , (height - 1, width - 1)` 까지 도는 `Iterator`.  
이걸 하기 위해서 쓸 수 있는 메소드도 역시나 이미 `Iterator`에 내장되어 있더라구요.  
`first_iterator.iter().flat_map(move |el| second_iterator.iter().map(move |el2| (el, el2)))` 이런 식으로 구현할 수 있습니다.

다만 정의에서부터 알 수 있듯이 각 iterator의 원소들이, N번씩 재사용되어야 하기 때문에 아마 `Copy, Clone`이 필요할 것 같습니다.
